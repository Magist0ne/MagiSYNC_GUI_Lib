处理请求分类：

1. 主动寄存器操作（数据类型的读写另外用函数封装，最后调用该功能）
   1. 读寄存器（uint16_t）
   2. 写寄存器（uint16_t）
2. 双向数据更新（MCU <--> GUI）
   1. 用于输入数据，一次最多传输249字节的数据，默认限制为128，即0X80（字节）（可配置成更大的，0X80方便变量分配）
   2. 双向数据读写，影子寄存器机制，需要注册函数和反注册函数，用一个单独的链表维护，数据方向为GUI -> MCU
      1. 影子寄存器机制（更安全，但出于节省空间的考虑，不支持字符串，支持的最大数据类型可配置）
         1. 每个变量存在Reg1和Reg2，各自有一个时间戳，时间戳由osKernelGetTickFreq();得到
         2. Reg1里面只包含一个时间戳，Reg2里面有一个指针、一个时间戳、一个8Byte的空间（作为影子寄存器，最长记录Double类型数据，不支持字符串）
         3. 屏幕更新数据，会先更新Reg1里面的时间戳，然后和Reg2里面的时间戳比较
            1. if(Reg1.Time	>	Reg2.Time){Data_GUI	->	*Reg2.pData;	Reg1.Time	->	Reg2.Time}
            2. if(Reg1.Time	<	Reg2.Time){Data_GUI	<-	*Reg2.pData;	Reg1.Time	<-	Reg2.Time}
         4. 
      2. 抢占机制（可能存在竞争与冒险）
         1. 双向覆盖
         2. 一个处理周期内，如果GUI更新，则GUI覆盖MCU，可多次覆盖（一般不会出现多次，除非GUI那边出问题）
         3. 一个处理周期内，如果GUI不更新，则MCU覆盖GUI，只覆盖一次
   3. 
3. 单向数据更新（MCU ---> GUI）
   1. 用于单纯的刷屏，一次最多传输249字节的数据，默认限制为128，即0X80（字节）（可配置成更大的，0X80方便变量分配）
   2. 该实现基于二级链表，一个大链表，每个节点代表一个页面ID，每个节点挂一个小链表，小链表的每个节点代表注册的数据
4. MessageProcess的Loop：
   1. 处理注册和反注册
   2. 处理一次双向数据更新
   3. 处理一次单向数据更新
   4. 处理一次常规数据读写：
      1. 先处理读请求，把读指令都发完，把读请求记入队列，
      2. 再处理写请求，把写指令都发完
      3. 最后集中处理返回的数据，根据第一步的队列分别返回数据
      4. 处理完后清空队列
   5. 进入阻塞延时
5. 
6. 
7. 